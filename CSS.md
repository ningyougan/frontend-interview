# CSS

## 选择器优先级

## 文档流

## 设备像素比

`window.devicePixelRatio`为1时，一个物理像素就和我们CSS中写的`1px`相对应，在移动端这个值往往会大于`1`，常见为`2`，所以我们拿到设计师给的750*1334的切图之后，实际要除以2才和iPhone 375*667的屏幕大小适配。

## 常见属性

### 盒模型与`box-sizing`

### `z-index`和层叠上下文

### `display`属性

### `position`属性

### CSS单位

### Flex和Grid布局

Flex布局本身好像没什么可说的，各种属性也没必要死记硬背，忘了就查。重点应该是理解为什么要用布局而非人工去计算位置，布局的意义在于提供一层抽象，避免CSS代码高度耦合，一个元素变了其他所有相关元素都需要重新计算位置，难以长期维护。

我之前面临的兼容性问题比较严重，业务要求适配低端机型，Grid布局用得很少，差不多还只是现查现用的状态。

#### 瀑布流

瀑布流布局算是前端一个比较常见的需求，在各种图片展示的场景都会遇到。我的解决方法也是从网上学来的：如果数据量固定且有限的话，可以利用`columns`做分列；如果是那种无限滚动加载的，用`flex`或者`grid`好像都行。`flex`设置两层容器，外层主轴水平负责分列，内层主轴垂直负责单列内容；`grid`的主要技巧是设置一个很小的固定行高`grid-auto-rows`，对每个元素都设置`grid-row-start: auto`自适应上边框所在网格线，然后用JS获取图片高度再除以这个固定高度以得到该图片应占据的行数，这样就可以通过设置`grid-row-end: span <行数>`实现动态行高；具体实现上为了展示效果的均衡还需要统计每列的高度，每次将图片填充到最短的列中。

然而条件允许的话在生产级代码中我只会默默找出isotope之类的开源库，避免自己花费太多时间在这些不喜欢的事情上……

## BEM

## Atomic CSS和Taiwind

## Headless UI
