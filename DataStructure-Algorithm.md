# 前端与算法和数据结构

> 写完发现数据结构的内容有点少，大概是因为常见的数据结构已经“润物细无声”了，很多是基础中的基础，而复杂的数据结构作为前端开发者来说应用得很少一时半会想不到。

## LeetCode刷题

我的算法挺烂的，一直觉得思路混乱没有条理，尤其讨厌在限定时间内面向Accept编程，刷LeetCode全靠套路，么得技巧。我是那种从暴力解法开始旁敲侧击寻求理解的风格，非常花时间，因此对大佬的灵光一闪只有叹为观止的份儿。看过比较推荐的算法教程是[LABULADONG 的算法网站](https://labuladong.github.io/algo/)，这老哥给我的感觉是语言朴实，各种见解的抽象程度很高，很多地方让人有拨云见日茅塞顿开醍醐灌顶恍然大悟之感，值得一读。

### 线性表

线性表常见的技巧是双指针，其中又可以分为快慢指针和左右指针两大类。快慢指针通常根据两个指针的交汇与否判断线性表的特征，有时还需要数组有序。左右指针可以从二分法的角度理解，更多的用于滑动窗口问题。我学来的一套滑动窗口极简框架如下，思路基本都是先尽可能增大窗口，然后判断`shouldShrink`缩小窗口：

```js
void slideWindow(str) {
  let left = 0;
  let right = 0;

  while (left <= right && right < str.length) {
    if (shouldShrink(left, right)) {
      // 缩小窗口
      left++;
    } else {
      // 增大窗口
      right++;
    }
  }
}
```

有关线性表的一个重要思想是“所有的数据结构其实都是线性表，只是我们对数据的解释方式不同”，这就好比对同一段二进制数据可以按照大端小端补码原码进行解释一样。从这个角度再去理解不同解释方式的特点很有启发。

有时链表问题的边界处理不太方便，可以考虑设置一个虚拟结点辅助解决。

### 回溯

这句话说得真是好：**回溯算法是在遍历“边”，DFS 算法是在遍历“节点”**。因为要遍历边，我们要在递归进入结点之前选中边，从结点子树出来之后，要取消选择然后选中兄弟边。每个边对应一个选择，通常用一个`for`循环遍历这些选择，而边下面的结点就是做了这个选择之后的结果。由此总结出回溯法的一般框架：

```js
void backtrace(nums) {
  // 对结点（选择后的结果）进行处理
  handleNode();

  for(let i = 0; i < nums.length; ++i) {
    // 剪枝
    if (shouldSkip(i)) continue;
    // 选中边
    choose(nums[i]);
    // 遍历子树
    backtrace(nums);
    // 取消选择
    unchoose(nums[i]);
  }
}
```

根据题目要求的不同，选中边之后的递归遍历`backtrace(nums)`也有说法，有时可能是`backtrace(nums.slice(i))`，分别对应如下回溯树（假定选项是1，2和3）：

<img src="./backtrace.png" />

后者可以通过前者剪枝得到。剪枝算是回溯的难点所在，但做多了也察觉到套路。~我就没有哪一次能秒杀成功的~，经验是把错误答案打印出来，辅助画出回溯树然后分析是那里没剪好。一般要把原始数据先排序，然后在`for`循环的索引上做文章，例如比较`nums[i]`和`nums[i-1]`的大小，索引不是自增1而是直接跳到非重复数据等等。

### BFS和最短路径

### 动态规划

### 最大流最小割

## DOM Diff算法

## CRC循环冗余

## Recursive Descent递归下降

## Shift Reduce移入归约
